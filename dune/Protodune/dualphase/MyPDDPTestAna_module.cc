////////////////////////////////////////////////////////////////////////
// Class:       MyAnalyzer
// Module Type: analyzer
// File:        MyPDDPTestAna_module.cc
//
// Generated at Tue Oct  8 14:37:54 2019 by RaphaÃ«l Bajou,,, using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <stdlib.h>
#include <string>
#include <vector>

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art_root_io/TFileService.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "canvas/Utilities/InputTag.h"

#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/SpacePoint.h"
#include "lardataobj/RecoBase/TrackHitMeta.h"

#include "larreco/Calorimetry/CalorimetryAlg.h"

#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"

#include "larcore/Geometry/Geometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"


#include "TTree.h"
#include "TH1D.h"

namespace test {
  class MyPDDPTestAna;
}

class test::MyPDDPTestAna : public art::EDAnalyzer {
public:
  explicit MyPDDPTestAna(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MyPDDPTestAna(MyPDDPTestAna const &) = delete;
  MyPDDPTestAna(MyPDDPTestAna &&) = delete;
  MyPDDPTestAna & operator = (MyPDDPTestAna const &) = delete;
  MyPDDPTestAna & operator = (MyPDDPTestAna &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  void beginJob();
  void endJob();

private:
  
  // Declare member data here.
  TTree *fOutputTree;
  
  #define kMAX 10000
  
  unsigned int fEventID;
  unsigned int fNPFParticles;
  unsigned int fNPrimaries;
  unsigned int fNPrimaryDaughters;
  unsigned int fNTracks;
  std::vector< double > fTrackLength;
  // double fNHits[kMAX], fNSpacepoints[kMAX]; //
  std::vector< unsigned int > fNHits, fNSpacepoints;
  std::vector< int > fView;
  std::vector< double > fX, fStartX, fEndX; 
  std::vector< double > fY, fStartY, fEndY;
  std::vector< double > fZ, fStartZ, fEndZ;
  std::vector< double > fStartDirectionX, fStartDirectionY, fStartDirectionZ;
  std::vector< double > fStartTime;
  std::vector< double > fPeakTime;
  std::vector< double > fHitIntegral;
  std::vector< double > fLifeCorr;
  std::vector< double > fdEdx;
  std::vector< double > fTicktoTime;
  //  std::vector< double > fPeakTime0;
  //  std::vector< double > fPeakTime1;
  //std::vector< double > fHitIntegral0; 
  //std::vector< double > fHitIntegral1; 
  //double fdQdx0[kMAX]; //
  std::vector< double > fdQdx0;
  std::vector< double > fdQdx1;
  std::vector< double > fdEdx0;
  std::vector< double > fdEdx1;
  std::vector< double > fdQdxtot;
  std::vector< int > fPlanenum;
  std::vector< double > fdEdx;

  std::string fPFParticleLabel;
  std::string fTrackModuleLabel;
  std::string fSpacePointModuleLabel;
  std::string fCalorimetryLabel;
  std::string fHitModuleLabel;
  
  calo::CalorimetryAlg fCalorimetryAlg;

  //Constantes
  double C = 89.1; //[ADC/fC] : calibration constante
  
  //Services
  detinfo::DetectorProperties const* fDetProp;
};


test::MyPDDPTestAna::MyPDDPTestAna(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)
  , fCalorimetryAlg(p.get<fhicl::ParameterSet>("CalorimetryAlg")) 
  , fDetProp(lar::providerFrom<detinfo::DetectorPropertiesService>())

// Initialize member data here.
{
  
  // Call appropriate produces<>() functions here.
  fPFParticleLabel       = p.get<std::string>("PFParticleLabel");
  fTrackModuleLabel      = p.get<std::string>("TrackModuleLabel");
  fSpacePointModuleLabel = p.get<std::string>("SpacePointModuleLabel");
  fCalorimetryLabel      = p.get<std::string>("CalorimetryLabel");
  fHitModuleLabel        = p.get<std::string>("HitModuleLabel");
  
  
}



void test::MyPDDPTestAna::analyze(art::Event const & e)                                       
{  
  // Implementation of required member function here.
  fEventID = e.id().event();
  double fDriftVelocity  = fDetProp->DriftVelocity(fDetProp->Efield(),fDetProp->Temperature());
  
  fNPFParticles = 0;
  fNPrimaries   = 0;
  fNTracks      = 0;
  
  art::Handle< std::vector<recob::PFParticle> > pfparticleListHandle;
  std::vector<art::Ptr<recob::PFParticle> > pfparticlelist;
  art::Handle< std::vector<recob::Track> > trackListHandle;
  std::vector<art::Ptr<recob::Track> > tracklist;
  art::Handle< std::vector<recob::SpacePoint> > spacepointListHandle;              
  std::vector<art::Ptr<recob::SpacePoint> > spacepointlist;
  art::Handle< std::vector<recob::Hit> > hitListHandle;       
  std::vector<art::Ptr<recob::Hit> > hitlist;
  if(e.getByLabel("pandora", pfparticleListHandle)) {
    art::fill_ptr_vector(pfparticlelist, pfparticleListHandle);
  }
  if(e.getByLabel("pandoraTrack", trackListHandle)) { //make sure the Handle is valid
    art::fill_ptr_vector(tracklist, trackListHandle);
  }
  if(e.getByLabel("pandora", spacepointListHandle)) {
    art::fill_ptr_vector(spacepointlist, spacepointListHandle);                      
  }
  if(e.getByLabel("dprawhit", hitListHandle)) {
    art::fill_ptr_vector(hitlist, hitListHandle);                
  }

  if(!pfparticlelist.size()) return;
  fNPFParticles = pfparticlelist.size();

  art::FindManyP<recob::Track> trackAssoc(pfparticlelist, e, fTrackModuleLabel); //accessing the recob::Track objects associated with everything in the pfparticlelist vector
  art::FindManyP<recob::SpacePoint> spacepointAssoc(pfparticlelist, e, fSpacePointModuleLabel);
  art::FindManyP<recob::Hit> hittrackAssoc(tracklist, e, fTrackModuleLabel);
  art::FindManyP<recob::Hit> hitspAssoc(spacepointlist, e, fHitModuleLabel);
  art::FindManyP<anab::Calorimetry> calorimetryAssoc(tracklist, e, fCalorimetryLabel);
  art::FindManyP<recob::Hit, recob::TrackHitMeta> fmthmAssoc(tracklist, e, fTrackModuleLabel);  
  //art::ServiceHandle<geo::Geometry> geom; 
  /*if (fmthmAssoc.isValid())
  {
      // loop over tracks                                                               
    for (size_t t = 0; t < trackListHandle->size(); ++t)
	{
	  auto vhit = fmthmAssoc.at(t);
	  auto vmeta = fmthmAssoc.data(t);

	}
	}*/

  
  for(const art::Ptr<recob::PFParticle> &pfp : pfparticlelist){   //Loop on pfparticles
        
    
    if( !(pfp->IsPrimary() && std::abs(pfp->PdgCode()) == 13) ) continue; 
    fNPrimaries++;
    std::vector< art::Ptr<recob::SpacePoint> > pfpspacepoint = spacepointAssoc.at(pfp.key());
    std::vector< art::Ptr<recob::Track> > pfptrack = trackAssoc.at(pfp.key());
    if(!pfptrack.empty() && !pfpspacepoint.empty()){
      //fNTracks++;
      // for(const art::Ptr<recob::SpacePoint> &sp : pfpspacepoint){
	// fX.push_back(sp->XYZ()[0]); fY.push_back(sp->XYZ()[1]); fZ.push_back(sp->XYZ()[2]); */
  //}
      /*for(const art::Ptr<recob::SpacePoint> &sp : pfpspacepoint){
		
	std::vector< art::Ptr<recob::Hit> > hitsp = hitspAssoc.at(sp.key());
	//if( !(hitsp.empty()) && hitsp->PeakTime() > 100 ) fNSpacepoints.push_back(hitsp.size());
	}*/
      //fNSpacepoints.push_back( pfpspacepoint.size() );
      //fNSpacepoints[pfp.key()] = pfpspacepoint.size();
      for(const art::Ptr<recob::Track> &trk: pfptrack){
	fNTracks++;
	fNHits.push_back( trk->NPoints() ); 
	std::vector< art::Ptr<recob::Hit> > trackhit = hittrackAssoc.at(trk.key());
	if(!trackhit.empty()){
	  if(!(trackhit[trk->FirstValidPoint()]->PeakTime() > 100) ) continue;
	
	  fTrackLength.push_back(trk->Length());
	  
	  fStartDirectionX.push_back(trk->StartDirection().X());
	  fStartDirectionY.push_back(trk->StartDirection().Y());
	  fStartDirectionZ.push_back(trk->StartDirection().Z());
	
	
	
	  fStartTime.push_back(trackhit[trk->FirstValidPoint()]->PeakTime());
          for(const art::Ptr<recob::Hit>  &hit : trackhit){
	    
	    int view = hit->WireID().Plane;
	    fView.push_back(view);
	    double time = hit->PeakTime();
	    fPeakTime.push_back(time);
	    double dq = hit->Integral();
	    fHitIntegral.push_back(dq);
	    
	  }  
        } 
	
	fStartX.push_back(trk->Start().X()); fStartY.push_back(trk->Start().Y()); fStartZ.push_back(trk->Start().Z());
        fEndX.push_back(trk->End().X()); fEndY.push_back(trk->End().Y()); fEndZ.push_back(trk->End().Z()); 
	
	

	
       	std::vector< art::Ptr<anab::Calorimetry> > trackcalo = calorimetryAssoc.at(trk.key());
        if (!trackcalo.empty()){
	  //	      std::cout << fDriftVelocity << std::endl;   
	  //	  std::cout << fDetProp->SamplingRate() << std::endl;
	  for (const art::Ptr <anab::Calorimetry> &cal : trackcalo){
	    if(!cal->PlaneID().isValid) continue; 
	    int planenum = cal->PlaneID().Plane;
	    

	    int calsize = cal->dQdx().size();

	    for(int i = 0; i < calsize ; i++){
	      fPlanenum.push_back(planenum);  
	      fX.push_back(cal->XYZ()[i].X()); fY.push_back(cal->XYZ()[i].Y()); fZ.push_back(cal->XYZ()[i].Z());
	      double timeconv = cal->XYZ()[i].X()  /  fDriftVelocity;    //in microsec
	      double lifetimecorr = fCalorimetryAlg.LifetimeCorrection(timeconv, 0.);  //in microsec
	      //std::cout << timeconv << ", ";
	      fTicktoTime.push_back(timeconv);  
	      fLifeCorr.push_back(lifetimecorr);
	      double dqdx = cal->dQdx()[i];
	      //  dqdx *= lifetimecorr;
	      dqdx /= C; // C = 89.1 [ADC/fC] 
	      double dedx  = fCalorimetryAlg.dEdx_AREA(dqdx*C, timeconv, planenum, 0.);
	      if(planenum == 0){ 
		fdQdx0.push_back( dqdx ); 
		fdEdx0.push_back( dedx );
	      }
	      else {
		fdQdx1.push_back( dqdx );
		fdEdx1.push_back( dedx );
	    }

	    
	    




	  }
	}//end if(!trackcalo.empty())

	fOutputTree->Fill(); 


	fTrackLength.clear();
	fNHits.clear(); fNSpacepoints.clear();
	fX.clear(); fY.clear(); fZ.clear();
	fStartDirectionX.clear(); fStartDirectionY.clear(); fStartDirectionZ.clear();
	fStartX.clear(); fStartY.clear(); fStartZ.clear(); 
	fEndX.clear(); fEndY.clear(); fEndZ.clear(); 
	fStartTime.clear();
	fView.clear();
	fPeakTime.clear();//fPeakTime0.clear(); fPeakTime1.clear();
	fHitIntegral.clear();//fHitIntegral0.clear(); fHitIntegral1.clear();  
	fdQdx0.clear(); fdQdx1.clear();
	fdEdx0.clear(); fdEdx1.clear();
	fdQdxtot.clear();
	fPlanenum.clear(); 
	fTicktoTime.clear();
	fLifeCorr.clear();
	fdEdx.clear();

    }//end for loop on pfptracks
    }//end if(!pfptrack.empty())
  }//end for loop on pfparticles
  
  

}

void test::MyPDDPTestAna::beginJob()
{
  // Implementation of optional member function here.
  art::ServiceHandle<art::TFileService> tfs;
  fOutputTree = tfs->make<TTree >("mytree", "My Tree");
  fOutputTree->Branch("eventID", &fEventID, "eventID/i");
  fOutputTree->Branch("nPFParticles", &fNPFParticles, "nPFParticles/i");
  fOutputTree->Branch("nPrimaries", &fNPrimaries, "nPrimaries/i");
  fOutputTree->Branch("nTracks", &fNTracks, "nTracks/i");
  fOutputTree->Branch("nPrimaryDaughters", &fNPrimaryDaughters, "nPrimaryDaughters/i");
  fOutputTree->Branch("TrackLength", &fTrackLength);//, "TrackLength/D");
  //fOutputTree->Branch("nHits", fNHits, "nHits[nTracks]/I");
  //fOutputTree->Branch("nSp", fNSpacepoints, "nSp[nPrimaries]/I");
  fOutputTree->Branch("nHits", &fNHits);//, "nHits/i");
  fOutputTree->Branch("nSp", &fNSpacepoints);//, "nSp/i");
  fOutputTree->Branch("X", &fX);//, "X/D" ); 
  fOutputTree->Branch("Y", &fY);//, "Y/D" );
  fOutputTree->Branch("Z", &fZ);//, "Z/D" );
  fOutputTree->Branch("StartDirectionX", &fStartDirectionX);
  fOutputTree->Branch("StartDirectionY", &fStartDirectionY);
  fOutputTree->Branch("StartDirectionZ", &fStartDirectionZ);
  fOutputTree->Branch("StartX", &fStartX);
  fOutputTree->Branch("StartY", &fStartY);
  fOutputTree->Branch("StartZ", &fStartZ);
  fOutputTree->Branch("EndX", &fEndX);
  fOutputTree->Branch("EndY", &fEndY);
  fOutputTree->Branch("EndZ", &fEndZ);
  fOutputTree->Branch("StartTime", &fStartTime);
  fOutputTree->Branch("View", &fView);
  fOutputTree->Branch("PeakTime", &fPeakTime);
  //fOutputTree->Branch("PeakTime0", &fPeakTime0);
  //fOutputTree->Branch("PeakTime1", &fPeakTime1);
  fOutputTree->Branch("HitIntegral", &fHitIntegral);
  //fOutputTree->Branch("HitIntegral0", &fHitIntegral0);
  //fOutputTree->Branch("HitIntegral1", &fHitIntegral1);
  //fOutputTree->Branch("dQdx0", fdQdx0, "dQdx0[]/D");
  fOutputTree->Branch("dQdx0", &fdQdx0);
  fOutputTree->Branch("dQdx1", &fdQdx1);
  fOutputTree->Branch("dEdx0", &fdEdx0);
  fOutputTree->Branch("dEdx1", &fdEdx1);
  fOutputTree->Branch("dQdxtot", &fdQdxtot);
  fOutputTree->Branch("Planenum", &fPlanenum); //, "");
  fOutputTree->Branch("TicktoTime", &fTicktoTime);//, "TicktoTime/D");
  fOutputTree->Branch("LifeCorr", &fLifeCorr);//, "LifeCorr/D");
  fOutputTree->Branch("dEdx", &fdEdx);//, "dEdx/D");
  //fdQdxhist = tfs->make<TH1D>("hdQdx", ";dQdx [fC/cm]", 50, 0, 50);
}

void test::MyPDDPTestAna::endJob()
{
}


DEFINE_ART_MODULE(test::MyPDDPTestAna)




